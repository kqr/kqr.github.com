---
layout: page
title: "About"
---
{% include JB/setup %}


About me
--------

I am Chris, a 20-odd year old ICT masters student from Sweden with a particular interest in fault-tolerant and/or distributed systems. I also enjoy photography, mathematics, natural languages, typography, design in general, procrastinating, learning things, nature, tea and cats. I like to consider myself a libertarian, upon further inspection however, you'll find that I'm a mess of mixed ideologies. But that is neither here nor there.

I've been programming since elementary school and sometimes it feels like I have been experimenting with every programming technique known to man by now. Of course, I haven't. I haven't even been close. It is true, though, that I have a problem with trying *everything* I can get my hands on.

I also have a problem with finishing things. I would really love to point to somewhere and say, "Look, I made that," but I can not. People tell me I do have a knack for both teaching and writing though, so I hope that will be good for this project.


About the book
--------------

The things that make this book unique are

 *  That it is **completely open**,
 *  That it uses **Haskell** as the teaching language, and
 *  That it is aimed at experienced computer users with **no prior programming knowledge**.

There are many books on programming out there. There are even many books on beginning programming. There is *not a single book* on beginning Haskell programming. The closest you will get is the bible called <abbr>sicp</abbr>, Structure and Implementation of Computer Programs, but it is very academic in nature, and Haskell didn't even exist when it was written.

I want to provide an accessible (but hard!) introduction to computer programming presented from a functional perspective. I say hard because I believe programming is inherently hard. You must have the motivation to go through with it, and I will not produce any half-measured explanations. I will either explain things properly or not at all. At times, you will be frustrated because I glance over things without explaining them; you'll have to trust me that the explanation would just make it worse at that time.

At first, I was writing this book in [LaTeX](http://en.wikipedia.org/wiki/LaTeX). I was intent on getting it published proper, on dead trees and all. After a while I realised that it will probably reach more people if I just put it "out there." So I decided to go the opposite route -- I decided to make it completely open and release the source for it on [GitHub](https://github.com/), the collaboration tool by programmers for programmers.

The book is far from complete, but I will be continuously improving on it and adding to it. My first priority is to get the first few (already written) chapters up to desired shape. As I proof-read when converting the LaTeX to [Markdown](http://en.wikipedia.org/wiki/Markdown) I noticed a few things that would be better off getting fixed.

Although I am the primary author of this book, I welcome all community support. There are links in the footer to access the source for the book and for reporting errors in the manuscript. If you are a developer, you are naturally free to fork me on GitHub.

The name of the book was initially just "hsp" because I love random letter combinations, but I continued to accidentally subvocalise it as "hasp" so that's what it became. If you need order in your life, you can pretend it stands for HASkell Programming. But really, it doesn't. It doesn't mean anything.


Code examples and exercises
---------------------------

With each part or "chapter," I have provided a multitude of examples and exercises. The point of these is not to frustrate you, but to help you. I encourage you not to copy and paste the examples, but to write them out character by character yourself. By replicating manually you will learn a lot quicker. In [Part 2](/2012/11/18/part-2-input-and-output/), I compare copy pasting code examples to running the answers of your homework through a photocopier. While you might get a grade, you don't learn much about the subject.

The exercises are likewise there to help you. I highly suggest completing all of them before moving on to the next part, because a solid understanding of each part is almost a requirement for being able to grasp the next part. You may of course find yourself experimenting with the code as you read, and when you get to the exercises you have already completed half of them unknowingly. This is fine and there's no reason to redo them then.

The exercises are listed roughly in order of difficulty, but there's no point in doing them in that order. Start with the first one, then try one in the middle, and then progress upward or downward depending on how easy the middle one was. I believe completing exercises is much more interesting if you do not do them from the first to the last, but mix challenging ones with boring ones.

I do not believe in answer sheets, and therefore I have not provided any solutions for the exercises. If you get stuck on a particular problem, you may of course contact me by e-mail with your questions. If a problem is ambiguously stated or incorrect, you should either file an error report with the link in the footer or contact me by e-mail.


License (CC BY-SA)
------------------
Content on this site is licensed under a [Creative Commons Attribution-ShareAlike 3.0 license](creativecommons.org/licenses/by-sa/3.0/). For more information about Creative Commons, check out [their web page](http://creativecommons.org/).

Unless otherwise explicitly stated, any contribution submitted for inclusion in this book by you to the licensor are under the terms and conditions of the [Creative Commons Attribution-ShareAlike 3.0 license](creativecommons.org/licenses/by-sa/3.0/), without any additional terms or conditions. All external contributions will be attributed below. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with the licensor regarding your contribution. 

